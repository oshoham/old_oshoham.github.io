<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>RC: Day 4 - Reverse-Engineering a Fragment Shader</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@" /><meta name="twitter:title" content="RC: Day 4 - Reverse-Engineering a Fragment Shader" /><meta name="twitter:description" content="After reading up on WebGL for a while, I ended up on Shadertoy and GLSL Sandbox, looking at other people’s cool fragment shaders and wondering, “How do any of these work???”. So, today I picked a s..."><meta name="description" content="After reading up on WebGL for a while, I ended up on Shadertoy and GLSL Sandbox, looking at other people’s cool fragment shaders and wondering, “How do any o..."><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/rc/2016/01/07/rc-day-4.html"><link rel="alternate" type="application/atom+xml" title="Oren Shoham" href="/feed.xml" /></head><body><aside class="logo"> <a href="/"> <img src="http://www.gravatar.com/avatar/2d7811c009f0757b7210095f88d32713.png?s=80" class="gravatar"> </a> <span class="logo-prompt">Back to Home</span></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>RC: Day 4 - Reverse-Engineering a Fragment Shader</h1><time>January 7, 2016</time></div><div class="divider"></div><p>After reading up on WebGL for a while, I ended up on <a href="shadertoy.com">Shadertoy</a> and <a href="glslsandbox.com">GLSL Sandbox</a>, looking at other people’s cool fragment shaders and wondering, “How do any of these work???”. So, today I picked a simple-ish shader and decided to go through it, line by line, until I understood what it was doing.</p><p>Many hours later, and with the help of Andrew A. and Andrew D., I ended up with this:</p><p><img src="/assets/rc-day-4/fragment_shader_whiteboard.jpg" alt="whiteboard madness" title="Glory." /></p><p>But I was worried that I’d quickly forget all the explanations that seemed really clear at the time, so I decided to write my notes up as a blog post. Let’s do this.</p><p><strong>Note:</strong> I’m assuming that you have a basic understanding of what WebGL is and how it works. If you’re totally new to WebGL, I’d recommend checking out <a href="https://stackoverflow.com/questions/7328472/how-webgl-works">this StackOverflow question</a> or <a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html">WebGL Fundamentals</a> before reading on.</p><p>Here’s our motivation:</p><canvas id="demo-1-canvas" style="width: 100%; height: 400px;"></canvas><p>And here’s the fragment shader that draws this cool circle-y thing, copied verbatim from <a href="http://glslsandbox.com/e#29842.0">http://glslsandbox.com/e#29842.0</a>:</p><div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">precision</span> <span class="k">mediump</span> <span class="k">float</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">vec2</span> <span class="n">resolution</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">float</span> <span class="n">time</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">vec2</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">resolution</span><span class="p">)</span> <span class="o">/</span> <span class="n">min</span><span class="p">(</span><span class="n">resolution</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">resolution</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
  <span class="k">vec3</span> <span class="n">destColor</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
  <span class="k">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="k">float</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mf">10.0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">float</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">0.628318</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
      <span class="k">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">0.628318</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
      <span class="n">f</span> <span class="o">+=</span> <span class="mf">0.0025</span> <span class="o">/</span> <span class="n">abs</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="k">vec2</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="k">vec3</span><span class="p">(</span><span class="n">destColor</span> <span class="o">*</span> <span class="n">f</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span></code></pre></div><p>At first glance, this seems pretty confusing (or at least it did to me <img class="emoji" title=":sweat_smile:" alt=":sweat_smile:" src="https://assets.github.com/images/icons/emoji/unicode/1f605.png" height="20" width="20" align="absmiddle" />). Single-character variable names, magic numbers, math that requires a solid understanding of high school geometry…what’s going on here? Well…</p><h2 id="variables">Variables</h2><div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">precision</span> <span class="k">mediump</span> <span class="k">float</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">vec2</span> <span class="n">resolution</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">float</span> <span class="n">time</span><span class="p">;</span></code></pre></div><p><code>precision mediump float;</code> tells the GPU to use medium precision when calculating floating point values. The other options are <code>lowp</code> and <code>highp</code>; a higher precision results in more accurate but slower calculations.</p><p><code>resolution</code> and <code>time</code> are uniforms that we pass in to the fragment shader when we render our scene. In the examples in this post, <code>resolution</code> is set to (<code>canvas.width</code>, <code>canvas.height</code>), while <code>time</code> is set to the current duration that our scene has been animating for, divided by 100. If we wanted to adjust the speed at which the scene animates, we could change the factor by which we scale <code>time</code>.</p><h2 id="converting-coordinates">Converting Coordinates</h2><div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">vec2</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">resolution</span><span class="p">)</span> <span class="o">/</span> <span class="n">min</span><span class="p">(</span><span class="n">resolution</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">resolution</span><span class="p">.</span><span class="n">y</span><span class="p">);</span></code></pre></div><p><code>gl_FragCoord</code> is a special shader variable that is always (and only) present in fragment shaders. The value of <code>gl_FragCoord</code> is the coordinates $(x, y, z, 1/w)$ of the center of the pixel that the current fragment is being rendered to, in <em>window coordinates</em>, which range from $(0.0, 0.0)$ to $(windowWidth, windowHeight)$. Since we’re drawing in 2D, we only care about the $(x, y)$ values.</p><p>This line converts the position of the pixel (hence the variable name <code>p</code>) to <em>normalized device coordinates</em>, which range from $(-1.0, -1.0)$ to $(1.0, 1.0)$. As an example, suppose we’re drawing on an 800x600 canvas, and we’re rendering the fragment that falls over the bottom-left corner of the canvas, which would have window coordinates of $(0.5, 0.5)$:</p><script type="math/tex; mode=display">p = ((0.5, 0.5) * 2.0 - (800, 600)) / 600 = (-0.99875, -0.99875)</script><p>Why do we want the pixel position in NDC? Well, WebGL draws pixels in terms of NDC (the vertex shader produces NDC), but in this case we’re basically doing all the work of drawing the geometry in our scene in our fragment shader, so if we want to draw in the correct locations on our canvas, we’ll need assign color values to fragments based on pixel positions in NDC space.</p><h2 id="color">Color</h2><div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">vec3</span> <span class="n">destColor</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span></code></pre></div><p>Here, we’re just setting up a color vector with the RGB values for light pink. Technically, <code>gl_FragColor</code> expects an RGBA <code>vec4</code>, not an RGB <code>vec3</code>, but since the alpha (opacity) value is going to be 1.0 and we’ll be multiplying this vector by a scalar value later on, it’s simpler to leave the alpha value off for now.</p><h2 id="drawing-a-circle">Drawing a Circle</h2><div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">for</span><span class="p">(</span><span class="k">float</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mf">10.0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">float</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">0.628318</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="k">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">0.628318</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="n">f</span> <span class="o">+=</span> <span class="mf">0.0025</span> <span class="o">/</span> <span class="n">abs</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="k">vec2</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">gl_FragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="k">vec3</span><span class="p">(</span><span class="n">destColor</span> <span class="o">*</span> <span class="n">f</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span></code></pre></div><p>There’s a fair amount going on here. Let’s start with the last line.</p><p>We’re setting <code>gl_FragColor</code> (the special variable that WebGL uses to set the color of the fragment being processed) to <code>destColor * f</code>. You can think of multiplying by <code>f</code> as applying a mask to <code>destColor</code>. Any coordinates that do not lie on the equation described by <code>f</code> will be black (because multiplying by 0 sets <code>gl_FragColor</code> to (0.0, 0.0, 0.0, 1.0)), and any fragments that do will be pink (because of the multiplicative identity).</p><p>Back to the geometry. Let’s ignore the for-loop, <code>s</code>, and <code>c</code> for a moment and simplify things down to this:</p><div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.0025</span> <span class="o">/</span> <span class="n">abs</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">);</span></code></pre></div><p>This produces a single circle drawn around $(0, 0)$:</p><canvas id="demo-2-canvas" style="width: 100%; height: 400px;"></canvas><p>But how? Let’s start with <code>length(p)</code> and work outwards. According to the <a href="https://www.opengl.org/sdk/docs/man/html/length.xhtml">OpenGL docs</a>,</p><script type="math/tex; mode=display">length(vector) = \sqrt{vector.x^2 + vector.y^2 + \dots}</script><p>The <a href="https://en.wikipedia.org/wiki/Circle#Equations">equation for graphing a circle</a> centered at the origin, i.e. $(0, 0)$, is $x^2 + y^2 = r^2$, which could also be written as $x^2 + y^2 - r^2 = 0$.</p><p>Using these definitions, we can rewrite $length(p) - 0.5$ as $p.x^2 + p.y^2 - 0.5^2$, which is the equation for a circle with a radius of 0.25.</p><p>However, <code>float f = length(p) - 0.5;</code> produces positive non-zero values for <em>all</em> coordinates on or outside of the circle, so if we stop here, we get the following:</p><canvas id="demo-3-canvas" style="width: 100%; height: 400px;"></canvas><p><code>float f = 0.0025 / (length(p) - 0.5</code> produces positive non-zero values for all coordinates that lie on or between the circle with radius 0.25 and the circle with radius 0.2525. You can think of 0.0025 as the radius of the ring comprised of these two circles. However, this produces a ring with a jagged inner edge, as you can see below:</p><canvas id="demo-4-canvas" style="width: 100%; height: 400px;"></canvas><p>Dividing by <code>abs(length(p) - 0.5)</code> doubles the width of the ring, which smoothes out its inner edge, by also including coordinates that fall between the circle with radius 0.2475 and the circle with radius 0.2525.</p><h2 id="trigonometry">Trigonometry</h2><p>Now that we understand how we’re drawing a circle, let’s add <code>s</code>, <code>c</code>, and <code>time</code>:</p><div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="k">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="k">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.0025</span> <span class="o">/</span> <span class="n">abs</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="k">vec2</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">);</span></code></pre></div><p>If you remember your high school geometry, given some angle $t$, $(cos(t), sin(t))$ are the $(x, y)$ coordinates at the intersection of the unit circle and a line that makes an angle of degree $t$ with the positive $x$-axis. As you vary $t$, you get a series of coordinates that define a rotation around edge of the unit circle.</p><p><img src="/assets/rc-day-4/sin_cos_unit_circle.png" alt="sin and cos on the unit circle" title="(cos(t), sin(t)) are (x, y) coordinates at the intersection of the unit circle and a line making an angle of t with the positive x-axis." class="center-image" /></p><p>Here, we’re using <code>time</code> as our angle <code>t</code>. An angle in radians greater than 2π wraps back around to 0, so as <code>time</code> increases, <code>vec2(c, s)</code> continues to describe a rotation around the unit circle. Well, not exactly the unit circle - because we multiply <code>sin(time)</code> and <code>cos(time)</code> by 0.5, <code>vec2(c, s)</code> actually describes a rotation around a circle with radius 0.5, and moves half as quickly.</p><p>Adding <code>vec2(c, s)</code> to <code>p</code> translates <code>p.x</code> by <code>c</code> and <code>p.y</code> by <code>s</code>, which causes our circle to orbit:</p><canvas id="demo-5-canvas" style="width: 100%; height: 400px;"></canvas><p>Okay, now back to the real code.</p><div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">for</span><span class="p">(</span><span class="k">float</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mf">10.0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">float</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">0.628318</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="k">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">0.628318</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="n">f</span> <span class="o">+=</span> <span class="mf">0.0025</span> <span class="o">/</span> <span class="n">abs</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="k">vec2</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">);</span>
<span class="p">}</span></code></pre></div><p>Each iteration of the loop draws an additional circle by adding <code>i * 0.628318</code> to the angle passed in to <code>sin</code> and <code>cos</code>, which offsets the position of the circle by <code>i * 0.628318</code>, and incrementing <code>f</code> by the circle formula.</p><p>Almost every pixel on the canvas will only fall on one of the 10 circles, so even though we increment <code>f</code> on every iteration of the loop, the value of <code>f</code> will still almost always be 0 or 1. However, if we didn’t offset <code>time</code> by <code>i * 0.628318</code>, we’d end up with one circle that was 10 times brighter. Note that the center of the canvas, where all 10 circles intersect, is much brighter:</p><canvas id="demo-6-canvas" style="width: 100%; height: 400px;"></canvas><p>Why are we multipling <code>i</code> by 0.628318? Because 0.628318 = $\frac{2\pi}{10}$!</p><p>If you look at the rendering above, you’ll see that we’re drawing 10 circles inscribed in an invisible outer circle, and each circle is equidistant from the two circles adjacent to it. An angle of 2π radians corresponds to a full circle, so you can divide a circle into 10 equal <a href="https://en.wikipedia.org/wiki/Circular_sector">circular sectors</a> if each sector has an angle of $\frac{2\pi}{10}$ radians. So by rotating our original circle by <code>i * 0.628318</code> (by adding <code>vec2(c, s)</code> to <code>p</code>) when we draw the $i^{th}$ circle, we ensure equal spacing between the circles.</p><p><img src="/assets/rc-day-4/circle_radians.gif" alt="radians in a circle" title="A full circle corresponds to an angle of 2π radians." class="center-image" /></p><h2 id="refactoring">Refactoring</h2><p>Finally, taking what we’ve learned, let’s rewrite the shader to be a little more readable:</p><div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="cp">#define PI 3.1415926535897932384626433832795</span>
<span class="cp">#define NUM_CIRCLES 10.0</span>
<span class="cp">#define CIRCLE_RADIUS_SQUARED 0.5</span>
<span class="cp">#define RING_RADIUS 0.0025</span>

<span class="k">precision</span> <span class="k">mediump</span> <span class="k">float</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">vec2</span> <span class="n">resolution</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">float</span> <span class="n">time</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">vec2</span> <span class="n">ndcPosition</span> <span class="o">=</span> <span class="p">(</span><span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">resolution</span><span class="p">)</span> <span class="o">/</span> <span class="n">min</span><span class="p">(</span><span class="n">resolution</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">resolution</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
  <span class="k">vec3</span> <span class="n">destColor</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span> <span class="c1">// pink</span>
  <span class="k">float</span> <span class="n">circlesMask</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="k">float</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_CIRCLES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">float</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">/</span> <span class="n">NUM_CIRCLES</span><span class="p">))</span> <span class="o">*</span> <span class="n">CIRCLE_RADIUS_SQUARED</span><span class="p">;</span>
      <span class="k">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">/</span> <span class="n">NUM_CIRCLES</span><span class="p">))</span> <span class="o">*</span> <span class="n">CIRCLE_RADIUS_SQUARED</span><span class="p">;</span>
      <span class="k">vec2</span> <span class="n">rotation</span> <span class="o">=</span> <span class="k">vec2</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
      <span class="k">vec2</span> <span class="n">circleWithRotation</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">ndcPosition</span> <span class="o">+</span> <span class="n">rotation</span><span class="p">);</span>
      <span class="n">circlesMask</span> <span class="o">+=</span> <span class="n">RING_RADIUS</span> <span class="o">/</span> <span class="n">abs</span><span class="p">(</span><span class="n">circleWithRotation</span> <span class="o">-</span> <span class="n">CIRCLE_RADIUS_SQUARED</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="k">vec3</span><span class="p">(</span><span class="n">destColor</span> <span class="o">*</span> <span class="n">circlesMask</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span></code></pre></div><script id="vertex-shader" type="x-shader/vertex"> attribute vec4 position; void main() { gl_Position = position; } </script> <script id="demo-1-fragment-shader" type="x-shader/fragment"> precision mediump float; uniform vec2 resolution; uniform float time; void main() { vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y); vec3 destColor = vec3(1.0, 0.3, 0.7); float f = 0.0; for(float i = 0.0; i < 10.0; i++) { float s = sin(time + i * 0.628318) * 0.5; float c = cos(time + i * 0.628318) * 0.5; f += 0.0025 / abs(length(p + vec2(c, s)) - 0.5); } gl_FragColor = vec4(vec3(destColor * f), 1.0); } </script> <script id="demo-2-fragment-shader" type="x-shader/fragment"> precision mediump float; uniform vec2 resolution; uniform float time; void main() { vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y); vec3 destColor = vec3(1.0, 0.3, 0.7); float f = 0.0025 / abs(length(p) - 0.5); gl_FragColor = vec4(vec3(destColor * f), 1.0); } </script> <script id="demo-3-fragment-shader" type="x-shader/fragment"> precision mediump float; uniform vec2 resolution; uniform float time; void main() { vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y); vec3 destColor = vec3(1.0, 0.3, 0.7); float f = length(p) - 0.5; gl_FragColor = vec4(vec3(destColor * f), 1.0); } </script> <script id="demo-4-fragment-shader" type="x-shader/fragment"> precision mediump float; uniform vec2 resolution; uniform float time; void main() { vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y); vec3 destColor = vec3(1.0, 0.3, 0.7); float f = 0.0025 / (length(p) - 0.5); gl_FragColor = vec4(vec3(destColor * f), 1.0); } </script> <script id="demo-5-fragment-shader" type="x-shader/fragment"> precision mediump float; uniform vec2 resolution; uniform float time; void main() { vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y); vec3 destColor = vec3(1.0, 0.3, 0.7); float s = sin(time) * 0.5; float c = cos(time) * 0.5; float f = 0.0025 / abs(length(p + vec2(c, s)) - 0.5); gl_FragColor = vec4(vec3(destColor * f), 1.0); } </script> <script id="demo-6-fragment-shader" type="x-shader/fragment"> precision mediump float; uniform vec2 resolution; uniform float time; void main() { vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y); vec3 destColor = vec3(1.0, 0.3, 0.7); float f = 0.0; for(float i = 0.0; i < 10.0; i++) { float s = sin(i * 0.628318) * 0.5; float c = cos(i * 0.628318) * 0.5; f += 0.0025 / abs(length(p + vec2(c, s)) - 0.5); } gl_FragColor = vec4(vec3(destColor * f), 1.0); } </script> <script src="/assets/rc-day-4/twgl-full.min.js"></script> <script src="/assets/rc-day-4/render-fragment-shader-demos.js"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], } }); </script> <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></article><div class="back"> <a href="/">Back</a></div></main></body></html>