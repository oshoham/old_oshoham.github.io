<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Recurse Center: Day 2</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@" /><meta name="twitter:title" content="Recurse Center: Day 2" /><meta name="twitter:description" content="Day 2! Today I learned a lot about what WebGL is and how it works by working through WebGL Fundamentals, and by talking through some questions with Andrew D. This should hopefully set me up well fo..."><meta name="description" content="Day 2! Today I learned a lot about what WebGL is and how it works by working through WebGL Fundamentals, and by talking through some questions with Andrew D...."><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/rc/2016/01/05/rc-day-2.html"><link rel="alternate" type="application/atom+xml" title="Oren Shoham" href="/feed.xml" /></head><body><aside class="logo"> <a href="/"> <img src="http://www.gravatar.com/avatar/2d7811c009f0757b7210095f88d32713.png?s=80" class="gravatar"> </a> <span class="logo-prompt">Back to Home</span></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>Recurse Center: Day 2</h1><time>January 5, 2016</time></div><div class="divider"></div><p>Day 2! Today I learned a lot about what WebGL is and how it works by working through <a href="http://webglfundamentals.org">WebGL Fundamentals</a>, and by talking through some questions with Andrew D. This should hopefully set me up well for working with Three.js down the road. I also got coffee with my half-sister, which was really nice but took up a few hours of productivity in the afternoon.</p><p><strong>Note:</strong> Most of this is cribbed almost verbatim from WebGL Fundamentals and this <a href="http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-ios-chapter-4.html">OpenGL for iOS blog</a>. I&#39;m just restating it for my own understanding.</p><h2 id="some-important-webgl-terms">Some Important WebGL Terms</h2><p><strong>Vertex:</strong> A point in 3D space, defined by <code>x</code>, <code>y</code>, and <code>z</code> values.</p><p><strong>Fragment:</strong> Every time that the GPU draws three vertices, it connects them to form a triangle (the technical term for this is a <em>primitive</em>). <em>Fragments</em> are the data provided by those three vertices for the purpose of drawing each pixel in that triangle. Each fragment corresponds to a single pixel, although one pixel may correspond to multiple fragments.</p><p><strong>Clipspace:</strong> The screen that WebGL draws on. Coordinates range from -1.0 to 1.0.</p><p><strong>Vertex Shader:</strong> A function that converts a vertex to clipspace coordinates (a 4D float vector made up of 3D coordinates and an additional value <code>w</code> used in matrix transformations). Handles moving, scaling, or rotating objects, simulating the perspective of human vision, and doing any other calculation that affects vertices or depends on some piece of data that you have on a per-vertex basis. Called once for each vertex that needs to be drawn.</p><p><strong>Rasterization:</strong> The process of mapping 3D or clipspace points to 2D pixels.</p><p><strong>Fragment Shader:</strong> A function that assigns a color to a fragment. Called once for each fragment that needs to be drawn.</p><p><strong>GLSL:</strong> A C-like language used to write shaders.</p><p><strong>Attribute:</strong> A shader variable for which you provide one distinct value (can be a variety of types) for each vertex being rendered. Only available in vertex shaders. For example, if you sent 1000 vertices to your vertex shader, you would need to supply 1000 values to any attribute that you passed to the shader.</p><p><strong>Uniform:</strong> A shader variable for which you provide a single, unchanging value (again, can be a variety of types). Available in both vertex and fragment shaders.</p><p><strong>Varying:</strong> A special kind of shader variable whose value is set in a vertex shader and can be passed from the vertex shader to a fragment shader. The value set in the vertex shader is automatically interpolated for use in the fragment shader based on the fragment&#39;s pixel&#39;s relative distance from the vertices that affect it.</p><p><img src="/assets/varying.jpg" alt="varying"></p><p>E.g., a varying set in the vertex shader for vertices V1 and V2 would have a value halfway between those two values when the fragment shader runs for fragment F. If the varying color was set to red in the vertex shader for V1 and to blue in the vertex shader for V2, when the fragment shader for the fragment corresponding to the pixel at F runs and reads that varying, it will will have a purple color, halfway between red and blue, because that fragment is roughly halfway between those two vertices.</p><h2 id="how-drawing-with-webgl-works-roughly">How Drawing With WebGL Works (Roughly)</h2><ol><li><p>2D/3D points describing a shape or object are passed to the vertex shader. In WebGL, you use buffers to pass values into <em>attributes</em> (as well as <em>uniforms</em> and <em>varyings</em>) in your shaders. As an example, we&#39;ll pass an array of 2D points representing 2 triangles into an attribute called <code>a_position</code>. WebGL seems to involve a lot of global state, which feels really clunky to me, but anyway here&#39;s how you do it:</p><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">setGeometry</span> <span class="p">(</span><span class="nx">gl</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// look up the memory location where the vertex data will need to go</span>
  <span class="kd">var</span> <span class="nx">positionLocation</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">someShaderProgram</span><span class="p">,</span> <span class="s2">&quot;a_position&quot;</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>

  <span class="c1">// load floats representing two triangles into the buffer</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">buffer</span><span class="p">);</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span>
    <span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span>
    <span class="k">new</span> <span class="nx">Float32Array</span><span class="p">([</span>
      <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>
       <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>
      <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span>
      <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span>
       <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>
       <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span>
    <span class="p">]),</span>
    <span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span>
  <span class="p">);</span>

  <span class="c1">// enable getting data out of a buffer for this attribute/memory location</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">positionLocation</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">numComponents</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// each vertex is comprised of 2 floats (x, y)</span>
  <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">;</span> <span class="c1">// this is presumably used to determine how many bytes each element in the buffer takes up</span>
  <span class="kd">var</span> <span class="nx">normalize</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// don&#39;t normalize the values (we don&#39;t need to worry about what this means right now)</span>
  <span class="kd">var</span> <span class="nx">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// start reading from the beginning of the buffer</span>
  <span class="kd">var</span> <span class="nx">stride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// how many bytes to move forward by to get to the next vertex</span>
                  <span class="c1">// 0 = the correct stride for type and numComponents</span>

  <span class="c1">// load the floats into the &quot;a_position&quot; attribute</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">positionLocation</span><span class="p">,</span> <span class="nx">numComponents</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">normalize</span><span class="p">,</span> <span class="nx">offset</span><span class="p">,</span> <span class="nx">stride</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></li><li><p>The GPU uses the <em>vertex shader</em> to determine how to map the points into clipspace. A simple vertex shader that just maps 2D coordinates directly to clipspace vertices might look like this (note the <code>a_position</code> attribute from earlier):</p><div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">attribute</span> <span class="k">vec2</span> <span class="n">a_position</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">a_position</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p><code>gl_Position</code> is a special variable whose value is used by the GPU to determine the clipspace value for the current vertex.</p></li><li><p>Assuming that the GPU is drawing <code>TRIANGLES</code> (and not <code>QUADS</code>), each time that the GPU generates 3 clipspace vertices, it will connect them together to form a triangle (if the GPU is drawing <code>QUADS</code>, it would presumbly connect 4 vertices to form a square). The GPU then <em>rasterizes</em> the triangle (i.e. draws it with pixels).</p></li><li><p>The GPU passes each pixel to the <em>fragment shader</em>, which determines which color the pixel should get. Here&#39;s a simple fragment shader that colors every pixel green:</p><div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// the first three values are RGB values, so vec4(0, 1, 0, 1) = green</span>
  <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></li></ol><p>As you can probably tell, doing any sort of sophisticated graphics in WebGL is more than a little tedious. However, I think it&#39;s important for me to understand how it works before I move on to higher level abstractions like Three.js that are built on top of it.</p><h2 id="what-i-will-do-tomorrow">What I Will Do Tomorrow</h2><ul><li>Continue working through WebGL Fundamentals</li><li>Start reading &quot;Foundations of 3D Computer Graphics&quot;</li></ul></article><div class="back"> <a href="/">Back</a></div></main></body></html>